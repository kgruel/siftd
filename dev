#!/usr/bin/env bash
# Unified development harness for siftd
# Usage: ./dev <command> [options]
set -euo pipefail

cd "$(dirname "$0")"

# Colors (disabled if not a terminal)
if [ -t 1 ]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[0;33m'
    BOLD='\033[1m'
    NC='\033[0m'
else
    RED='' GREEN='' YELLOW='' BOLD='' NC=''
fi

usage() {
    cat <<EOF
${BOLD}siftd development harness${NC}

${BOLD}Usage:${NC} ./dev <command> [options]

${BOLD}Commands:${NC}
  setup [--embed]    Setup worktree (venv, deps, optional embeddings)
  lint               Run ty type checker + ruff linter (with autofix)
  test [-v]          Run tests (excluding embeddings)
  test-all [-v]      Run all tests including embeddings
  docs [--check]     Generate docs; --check fails if stale
  check [-v]         Run lint + test (CI equivalent, quiet by default)
  review <task>      Enter subtask worktree and launch review agent
  help               Show this message

${BOLD}Examples:${NC}
  ./dev setup                        # Basic worktree setup
  ./dev setup --embed                # Setup with embeddings
  ./dev check                        # Quick CI check (minimal output)
  ./dev check -v                     # Verbose CI check
  ./dev review impl/my-feature       # Review subtask with codex
  ./dev review impl/my-feature claude  # Review with claude instead
EOF
}

cmd_setup() {
    local with_embed=0
    for arg in "$@"; do
        case "$arg" in
            --embed) with_embed=1 ;;
            *) echo "Unknown option: $arg"; exit 1 ;;
        esac
    done

    # Create venv if missing
    if [ ! -d ".venv" ]; then
        echo "Creating venv..."
        uv venv .venv
    fi

    # Sync dev dependencies
    echo "Syncing dependencies..."
    uv sync --extra dev --quiet

    # Optional: embeddings setup
    if [ $with_embed -eq 1 ]; then
        echo "Installing embeddings dependencies..."
        uv sync --extra dev --extra embed --quiet

        echo "Warming fastembed cache (downloading model)..."
        uv run python -c "from fastembed import TextEmbedding; TextEmbedding(model_name='BAAI/bge-small-en-v1.5')" 2>/dev/null || {
            echo -e "${YELLOW}Warning: Could not warm fastembed cache${NC}"
        }

        echo "Running initial ingest..."
        uv run siftd ingest || {
            echo -e "${YELLOW}Warning: Ingest had issues (may be first run)${NC}"
        }
    fi

    echo -e "${GREEN}Worktree ready.${NC} Run ./dev check to verify."
}

cmd_lint() {
    # Auto-setup if venv missing
    if [ ! -d ".venv" ]; then
        cmd_setup
    fi

    local errors=0

    # Type check - show only errors/warnings
    echo "Running ty..."
    set +e
    ty_out=$(uv run ty check src/ 2>&1)
    ty_status=$?
    set -e

    if [ $ty_status -ne 0 ]; then
        echo "$ty_out" | grep -E "^(error|warning)\[" | head -20
        errors=1
    fi

    # Lint with autofix
    echo "Running ruff..."
    set +e
    ruff_out=$(uv run ruff check src/ --fix 2>&1)
    ruff_status=$?
    set -e

    if [ $ruff_status -ne 0 ]; then
        echo "$ruff_out" | grep -v "^\[" | head -20
        errors=1
    fi

    if [ $errors -eq 0 ]; then
        echo -e "${GREEN}Lint passed${NC}"
    else
        echo -e "${RED}Lint failed${NC}"
        exit 1
    fi
}

cmd_test() {
    # Auto-setup if venv missing
    if [ ! -d ".venv" ]; then
        cmd_setup
    fi

    local verbose=0
    for arg in "$@"; do
        case "$arg" in
            -v|--verbose) verbose=1 ;;
        esac
    done

    if [ $verbose -eq 1 ]; then
        uv run pytest tests/ -v --tb=short -m "not embeddings"
    else
        # Quiet mode: minimal output, details only on failure
        echo "Running tests (excluding embeddings)..."
        set +e
        output=$(uv run pytest tests/ -q --tb=line -m "not embeddings" 2>&1)
        status=$?
        set -e
        if [ $status -ne 0 ]; then
            echo "$output"
            exit 1
        fi
        # Show just the summary line
        echo "$output" | tail -1
    fi
}

cmd_test_all() {
    # Auto-setup if venv missing
    if [ ! -d ".venv" ]; then
        cmd_setup --embed
    fi

    local verbose=0
    for arg in "$@"; do
        case "$arg" in
            -v|--verbose) verbose=1 ;;
        esac
    done

    if [ $verbose -eq 1 ]; then
        uv run pytest tests/ -v --tb=short
    else
        echo "Running all tests..."
        set +e
        output=$(uv run pytest tests/ -q --tb=line 2>&1)
        status=$?
        set -e
        if [ $status -ne 0 ]; then
            echo "$output"
            exit 1
        fi
        echo "$output" | tail -1
    fi
}

cmd_docs() {
    local check_mode=0
    for arg in "$@"; do
        case "$arg" in
            --check) check_mode=1 ;;
            *) echo "Unknown option: $arg"; exit 1 ;;
        esac
    done

    # Auto-setup if venv missing
    if [ ! -d ".venv" ]; then
        cmd_setup
    fi

    echo "Generating docs..."
    uv run python scripts/gen_docs.py

    if [ $check_mode -eq 1 ]; then
        # Check if any docs changed
        if ! git diff --quiet docs/reference/; then
            echo -e "${RED}Docs are stale. Run './dev docs' to regenerate.${NC}"
            git diff --stat docs/reference/
            exit 1
        fi
        echo -e "${GREEN}Docs are up to date${NC}"
    fi
}

cmd_check() {
    local verbose=0
    for arg in "$@"; do
        case "$arg" in
            -v|--verbose) verbose=1 ;;
        esac
    done

    if [ $verbose -eq 1 ]; then
        echo -e "${BOLD}=== Lint ===${NC}"
        cmd_lint
        echo ""
        echo -e "${BOLD}=== Test ===${NC}"
        cmd_test -v
    else
        # Quiet mode: single line per step
        printf "Lint... "
        cmd_lint > /dev/null 2>&1 && echo -e "${GREEN}ok${NC}" || { echo -e "${RED}failed${NC}"; cmd_lint; exit 1; }
        printf "Test... "
        cmd_test > /dev/null 2>&1 && echo -e "${GREEN}ok${NC}" || { echo -e "${RED}failed${NC}"; cmd_test; exit 1; }
    fi

    echo -e "${GREEN}All checks passed${NC}"
}

cmd_review() {
    local task=""
    local agent="codex"
    local dry_run=0

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --dry-run) dry_run=1 ;;
            codex|claude) agent="$1" ;;
            -*) echo "Unknown option: $1"; exit 1 ;;
            *) task="$1" ;;
        esac
        shift
    done

    if [ -z "$task" ]; then
        echo "Usage: ./dev review <task> [agent] [--dry-run]"
        echo "  task:     subtask name (e.g., impl/peek-parent-session)"
        echo "  agent:    codex (default), claude"
        echo "  --dry-run show prompt without launching agent"
        exit 1
    fi

    # Get worktree path
    local worktree
    worktree=$(subtask workspace "$task" 2>/dev/null) || {
        echo -e "${RED}Error: Could not find worktree for task '$task'${NC}"
        echo "Run 'subtask list' to see available tasks"
        exit 1
    }

    echo -e "${BOLD}Task:${NC} $task"
    echo -e "${BOLD}Worktree:${NC} $worktree"

    # Setup if needed
    if [ ! -d "$worktree/.venv" ]; then
        echo "Setting up worktree..."
        (cd "$worktree" && ./dev setup)
    fi

    # Get task info for prompt
    local title changes
    title=$(subtask show "$task" 2>/dev/null | grep "^Title:" | cut -d: -f2- | xargs)
    changes=$(subtask show "$task" 2>/dev/null | grep "^Changes:" | cut -d: -f2- | xargs)

    # Build review prompt
    local prompt
    prompt="Review the $task branch: $title

Changes: $changes

## Dev Commands
\`\`\`
./dev check          # Lint + test (quiet)
./dev check -v       # Lint + test (verbose)
./dev lint           # Type check + lint only
./dev test           # Run tests only
./dev test -v        # Run tests (verbose)
\`\`\`

## Review Focus
1. Does the implementation match the task description?
2. Are there any architectural violations (check CLAUDE.md)?
3. Is error handling consistent with existing patterns?
4. Are tests comprehensive?
5. Run \`./dev check\` to verify lint and tests pass.

Start by reading the task description: \`cat .subtask/tasks/${task//\//--}/TASK.md\`
Then review the diff: \`git diff main\`"

    if [ $dry_run -eq 1 ]; then
        echo ""
        echo -e "${BOLD}Review prompt:${NC}"
        echo "----------------------------------------"
        echo "$prompt"
        echo "----------------------------------------"
        echo ""
        echo -e "${BOLD}To launch:${NC} cd $worktree && $agent \"<prompt>\""
    else
        echo ""
        echo -e "${BOLD}Launching $agent in worktree...${NC}"
        echo ""

        case "$agent" in
            codex)
                (cd "$worktree" && exec codex "$prompt")
                ;;
            claude)
                (cd "$worktree" && exec claude "$prompt")
                ;;
            *)
                echo "Unknown agent: $agent (use 'codex' or 'claude')"
                exit 1
                ;;
        esac
    fi
}

# Main dispatch
case "${1:-help}" in
    setup)    shift; cmd_setup "$@" ;;
    lint)     cmd_lint ;;
    test)     shift; cmd_test "$@" ;;
    test-all) shift; cmd_test_all "$@" ;;
    docs)     shift; cmd_docs "$@" ;;
    check)    shift; cmd_check "$@" ;;
    review)   shift; cmd_review "$@" ;;
    help|--help|-h) usage ;;
    *)
        echo "Unknown command: $1"
        echo "Run './dev help' for usage"
        exit 1
        ;;
esac
